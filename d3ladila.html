<!doctype html>
<html>
<head>
    <style>
        svg {
            width: 500px;
            height: 500px
        }

        button {
            float: left
        }

        .line {
            stroke: red;
            stroke-width: 3;
            fill: none;
        }

        text {
            font-size: 22px;
            font-family: Helvetica;
            fill: white;

            text-anchor: middle;
            text-align: center;
        }

        circle {
            fill: blue;
            stroke: orange;
            fill-opacity: 0.5;
        }

        .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .axis path {
            fill: none;
        }

        .axis text {
            font-size: 0.7em;
            fill: #555;
            font-family: sans-serif
        }
    </style>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="./GradientLineAnim.js"></script>
    <script src="./Neuron.js"></script>
    <script src="./Graph.js"></script>
    <script src="./NeuralNet.js"></script>
</head>
<body>
<script>
    //    import {GradientLineAnim} from './GradientLineAnim';
    //TODO stuff that goes into the gate:
    const intInputs = [
        3, //f1, //f2
        2,
        5,
        8,

    ]

    const startData = intInputs.map((el, i) =>
        new Node({
            value: el,
            x: 200,
            id: 'feature_' + i,
            y: 230 * i, //200 = spacing
            level: 0

        })
    )

    const Graph = { //TODO make GRAPH a class....?
        treeHeight: 0,
        stepSize: 0.1,
        layers: [
            [
                ...startData //features
            ],
            [
                new Gate({level: 2}),
                new Gate({level: 2, y: 400})
            ],
            [
                new Gate({x: 900, y: 600, level: 3, gradient: 1}) // initialize ouput grad at 1 otherwise multi with 0
            ]
        ],
        connectLayers(layers = this.layers) {
            layers.forEach(function (layer, idx) {
                if (idx >= layers.length - 1) {
                    return
                }
                layer.forEach(function (node) {
                    layers[idx + 1].forEach(next => node.connectTo(next, node)) //basically just case for the inputs...refactor...
                }) //connects all nodes with all gates next layer
            })
            return this
        },
        forwardPassAll(layers = this.layers) { //all gates call forward()
            //
            for (let i = 1; i < layers.length; i++) {
                layers[i].forEach(gate => gate.forward())
            }
            return this
        },

        backwardPassAll(layers = this.layers) {
            for (let i = layers.length - 1; i >= 1; i--) { //skip last (inputlayer nodes)
                layers[i].forEach(gate => gate.backward())
            }
            return this
        },
        adjustInputsToGradient(layers = this.layers) {
            const that = this;
            layers.forEach(layer => layer.forEach(function (node) {
                    node.value += that.stepSize * node.gradient
                })
            )
            return this;

        }
    }

    const initalMatrix = new NeuralNet().matrix;

    startData //TODO replace with simple node drag to change value
        .map(createSlider)
        .map(e => document.body.appendChild(e))

    function createSlider(node) { //TODO replace with action done UNTO element itself
        const sl = document.createElement('input')
        sl.setAttribute('type', 'range')
        sl.setAttribute('class', 'slider')
        sl.style.position = 'absolute'
        sl.style.left = node.x + 'px'
        sl.style.top = node.y + 'px'
        sl.setAttribute('id', node.id)
        sl.addEventListener('input', function () {
            node.value = +sl.value / 5
            console.log(node.value)
            updateNodeFromSlider(node)
        })
        console.log(sl)
        return sl
    }

    var svg = d3.select('body')
        .append('svg');

    svg.style('width', window.innerWidth * 0.9 + 'px').style('height', window.innerHeight * 0.9 + 'px'); //+px for Firefox..chrome works/assumes

    function drawGraphNodes(layers, container) {
        layers.forEach(function (layer) {
            let nodesG = svg.selectAll('gr').data(layer).enter()
                .append('g')
                .attr('transform', d => `translate(${d.x}, ${d.y})`)

            const rectSize = 60;
            const nodes = nodesG.append('rect')
                .attr('x', d => -rectSize / 2)
                .attr('y', d => -rectSize / 2)
                .attr('width', d => rectSize)
                .attr('height', d => rectSize)
                .attr('id', d => 'node_' + d.id)
                .attr('fill', "lightblue")
                .attr('stroke', 'grey')
                .attr('stroke-opacity', '0.5')


            let textNodes = nodesG.append('text')
                .attr("dx", d => +nodes.node().getAttribute('width') / 2)
                .attr("dy", d => +nodes.node().getAttribute('height') / 1.5)
                .attr('x', d => -rectSize / 2)
                .attr('y', d => -rectSize / 2)
                .classed('text', true)
                .html(d => d.value || "A")
        })
    }


    const gradAnim = new GradientLineAnim('red');


    function drawGraphLinks(layers, container) { //requires the nodes to be linked up

        layers.forEach(function (layer, i) {
            console.log(layer)
            const pathGroup = svg.append('g');
            layer.forEach(function (node) {
                if (node.to) {
                    node.to.forEach(function (target) {
                        pathGroup.append('path')
                            .attr("d", sigmoidLine({from: node, to: target}))
                            .classed('line', true)
                            .style('stroke', node.y - target.y < 0 ? "url(#gradientDown)" : "url(#gradientUp)")
                    })
                }
            })
        })
    }

    Graph.connectLayers()
        .forwardPassAll()
        .backwardPassAll()
        .adjustInputsToGradient();

    drawGraphLinks(Graph.layers, svg)

    drawGraphNodes(Graph.layers, svg)

    function sigmoidLine(d) { // topNode = parent, utop...
        const f = d.from;
        const t = d.to;
        //TODO always start the path with the parent --> child
        return "M" + f.x + "," + f.y
            + "C" + (f.x + t.x) / 2 + "," + f.y
            + " " + (f.x + t.x) / 1.9 + "," + t.y
            + " " + t.x + "," + t.y // * (1 + (-0.5/20 + Math.random()/20))
    };

    function updatePathThickness() {

    }

    //2 gradients per layer --- to have non parallel anim....
    function promiseLandFlow() {
        gradAnim.animateGradient('forward')
            .then(function () {
                Graph.forwardPassAll();
                gradAnim.animateGradient('backward')
                    .then(function () {
                        Graph.backwardPassAll()
                        promiseLandFlow();
                    })
            })
    }

    promiseLandFlow()

</script>
</html>