<!doctype html>
<html>
<head>
    <style>
        svg {
            width: 500px;
            height: 500px
        }

        button {
            float: left
        }

        .line {
            stroke: red;
            stroke-width: 3;
            fill: none;
        }

        text {
            font-size: 40px;
            font-family: Helvetica;
            fill: white;

            text-anchor: middle;
            text-align: center;
        }

        circle {
            fill: blue;
            stroke: orange;
            fill-opacity: 0.5;
        }

        .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .axis path {
            fill: none;
        }

        .axis text {
            font-size: 0.7em;
            fill: #555;
            font-family: sans-serif
        }
    </style>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="./gradientSchabernak.js"></script>
</head>
<body>
<script>

    //TODO stuff that goes into the gate:
    //....forward(nodes) /array
    //this.inputNodes = nodes...
    const Gate_add = class { //or call Neuron //TODO GATE extends Node ?
        constructor(parameters) {
            const presets = {
                id: 'gate',
                rectSize: 60,
                x: 200,
                y: 200,
                from: [],
                level: 2
            }
            //presets go on this and parameters override presets
            Object.assign(this, presets, parameters)
            this.x = this.level * 200 + 200;
            this.output = new Node({ //only value transfer at this stage, no reference
                from: this,
                level: this.level + 1,
                x: this.x,
                id: `output`,
                y: this.y, //between the two
                to: []
            }, 0);
        }

        forward() {
//            this.nodeA = this.from[0]
//            this.nodeB = this.from[1]
            this.y = this.from.reduce((acc, node) => acc + node.y, 0) / this.from.length + 100;
            this.outputVal = this.from.reduce((acc, node) => acc + node.value, 0);

            this.output.value = this.outputVal;

            //this.to = this.outputNode;

            return this.output;
        }

        backward() {//derivative of xy ref x = x; that's why x ==> y
            // take the gradient in output unit and chain it with the
            // local gradients, which we derived for multiply gate before
            // then write those gradients to those Units.
            //TODO understand that these are all gradients!!!
            //even latter in multgate nodeB.value = derivative von node.A
            //VALUES get changed after a full backprop cycle
            this.nodeA.gradient += 1 * this.outputNode.gradient; //f(x) = x + y; f`(x/dx) = 1 -- local gradient chained with outputgradient
            this.nodeB.gradient += 1 * this.outputNode.gradient;
        }
    }

    //TODO BASEgate class ...multiply / addgate as extensions
    //TODO GRAPh and nodes and gates only care about linking and graph
    // TODO related stuff...x, y coordinates is a map function...value as well. Don't code it in the object....the object does the graph. Then there are valuemapping functions for paths, width etc


    //TODO wire is a dead, simple neuron without a functionality...just values and gradient
    const Node = class { //saves in object to have memory off variables (assignment by reference)...
        constructor(parameters) {
            const presets = {
                id: null,
                value: 20,
                gradient: 0,
                x: 200,
                y: 200,
                from: [],
                to: [],
                level: null
            }
            //presets go on this and parameters override presets
            Object.assign(this, presets, parameters)
        }

        connectTo(target, source = this) { //by reference attention
            if (this.to.indexOf(target) === -1) {
                this.to.push(target);
            }
            if(target.from.indexOf(source) === -1) {
                target.from.push(source)
                if (!target.level) {
                    target.level = source.level + 1
                }
            }

        }
    };

    const intInputs = [
        3, //f1, //f2
        2,
        5,
        8,
        9

    ]

    const startData = intInputs.map((el, i) =>
        new Node({
            value: el,
            x: 200,
            id: 'feature_' + i,
            y: 230 * i, //200 = spacing
            level: 0

        })
    )
    const Graph = { //TODO make GRAPH a class....?
        treeHeight: 0,
        layers: [
            [
                ...startData
            ],
            [
                new Gate_add({level:2})
            ],
            [
                new Gate_add({x: 900, y: 400, level:3})
            ]
        ],
        resultNode: new Node(
            {
                x: window.innerWidth * 0.8,
                y: 500,
                id: 'result',
                value: null
            }),
        connectLayers(layers = this.layers) {
            layers.forEach(function (layer, idx) {
                if (idx >= layers.length-1) {
                    return
                }
                layer.forEach(function (node) {
                    if (node.id.indexOf('gate') > -1){
                        layers[idx+1].forEach(next => node.output.connectTo(next, node.output)) //node = gate
                        node.to = node.output.to
                    }
                    else {
                        layers[idx+1].forEach(next => node.connectTo(next, node)) //basically just case for the inputs...refactor...
                    }
                    console.log(node)
                    console.log(layers[idx])
                }) //connects all nodes with all gates next layer
            })
        },
        connectNodes() {

        },
        forwardPassAll(layers = this.layers) { //all gates call forward()
            //
            for (let i = 1; i < layers.length; i++) {
                layers[i].forEach(gate => gate.forward())
            }
        },

        backwardPass() {
        }
    }

    //FIRST DATA LAYER === FEATURES!!
    //2n LAYER === NEURONS' local OUTPUT!!
    //last LAYER === yHat ...

    //TODO BRUTE FORCE FIRST - BFF


    //TODO map into obj
    //gradient --> derivative
    //WIRE to NEURONS in next LAYER
    //LET NEURONS forward PROP
    //WIRE Wires to next layer
    //when done...backpropagate in reverse layer order

    console.log(startData)

    //keep the neuron stupid



//    const addGate = new Gate_add(2);
    console.log(startData, 'startData')
//    startData.forEach(d => d.connectTo(addGate))


//    const outputAB = addGate.forward() //TODO make for multiple inputs [...data]

    //TODO classes that go in arrays...with


    const l = startData //TODO replace with simple node drag to change value
        .map(createSlider)
        .map(e => document.body.appendChild(e))

    function createSlider(node) { //TODO replace with action done UNTO element itself
        const sl = document.createElement('input')
        sl.setAttribute('type', 'range')
        sl.setAttribute('class', 'slider')
        sl.style.position = 'absolute'
        sl.style.left = node.x + 'px'
        sl.style.top = node.y + 'px'
        sl.setAttribute('id', node.id)
        sl.addEventListener('input', function () {
            node.value = +sl.value / 5
            console.log(node.value)
            updateNodeFromSlider(node)
        })
        console.log(sl)
        return sl
    }

    var svg = d3.select('body')
        .append('svg');

    svg.style('width', window.innerWidth * 0.9 + 'px').style('height', window.innerHeight * 0.9 + 'px'); //+px for Firefox..chrome works/assumes


    function drawGraphNodes(layers, container){
        layers.forEach(function(layer){
            let nodesG = svg.selectAll('gr').data(layer).enter()
                .append('g')
                .attr('transform', d => `translate(${d.x}, ${d.y})`)

            const nodes = nodesG.append('rect')
                .attr('width', d => 60)
                .attr('height', d => 60)
                .attr('id', d => 'node_' + d.id)
                .attr('fill', "url(#gradientUp)")
                .attr('stroke', 'grey')
                .attr('stroke-opacity', '0.7')


            let textNode = nodesG.append('text')
                .attr("dx", d => +nodes.node().getAttribute('width') / 2)
                .attr("dy", d => +nodes.node().getAttribute('height') / 2)
                .classed('text', true)
                .html(d => d.value || "A")
        })
    }
    const gradientDown = svg.append("defs")
        .append("linearGradient")
        .attr("id", "gradientDown")
        .attr("x1", "0%").attr("y1", "0%")
        .attr("x2", "0%").attr("y2", "100%");

    gradientDown.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "red")
        .attr("stop-opacity", 0.8);
    gradientDown.append("stop")
        .attr('offset', '40%')
        .attr('class', 'motionBefore')
        .attr("stop-color", "red")
        .attr("stop-opacity", 0.8);


    gradientDown.append("stop")
        .attr('offset', '50%')
        .attr('class', 'motion')
        .attr("stop-color", "white")
        .attr("stop-opacity", 1);

    gradientDown.append("stop")
        .attr('offset', '60%')
        .attr('class', 'motionAfter')
        .attr("stop-color", "red")
        .attr("stop-opacity", 0.8);
    gradientDown.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "red")
        .attr("stop-opacity", 0.8);

    const gradientUp = svg.append("defs")
        .append("linearGradient")
        .attr("id", "gradientUp")
        .attr("x1", "0%").attr("y1", "100%")
        .attr("x2", "0%").attr("y2", "0%")
        .attr('xlink:href',"#gradientDown")

    //x1="1" y1="1" x2="0" y2="0"></linearGradient>


        let offset = 50;
    let forward = true;

    setInterval(function() {
        if (forward) {
            offset++
        }
        else {
            offset--
        }
        if (offset>130) {
            forward = false
            d3.select('.motion').attr("stop-color", 'purple')

        }
        else if (offset < -30){
            forward = true
            d3.select('.motion').attr("stop-color", 'yellow')

        }

        d3.select('.motion').attr("offset", offset+'%')
        d3.select('.motionBefore').attr("offset", offset-15+'%')
        d3.select('.motionAfter').attr("offset", offset+15+'%')
    }, 20)



    function drawGraphLinks(layers, container){ //requires the nodes to be linked up

        layers.forEach(function(layer,i){
            console.log(layer)
            const path = svg.selectAll('.line' + i).data(layer).enter()
                .append('path')


                .attr("d", d => {
                    console.log(d.from, d.to[0], "gate")


                    console.log('d,xx', d.y - d.to[0].y < 0)

                    return sigmoidLine({from: d.to[0], to:d })
                })
                .classed('line', true)
                .style('stroke', d => d.y - d.to[0].y < 0 ? "url(#gradientDown)": "url(#gradientUp)")
        })


    }
    Graph.connectLayers();
    Graph.forwardPassAll();
    drawGraphNodes(Graph.layers, svg)
    drawGraphLinks(Graph.layers, svg)

    //OUT PUT of GATE
//    const outputG = svg.selectAll('.output').data([addGate.output])
//        .enter().append('g');
//
//
//    outputG.attr('transform', (d, i) => `translate(${d.x}, ${d.y})`) //-- g doesn't do x, y coords...translate needed
//    //NOW ALL CHILDREN ARE POSITIONED RELATIVE --- NO NEED TO SET ABSOLUTE VALUES
//
//    outputG.append('rect')
//        .attr('width', d => d.value)
//        .attr('id', d => d.id)
//        .attr('height', d => d.value)
//
//    outputG.append('text')
//        .attr("dy", ".35em")
//        .text(d => d.value)


    function update() {
        outputG.select('rect').attr('height', d => d.value)
        textNode.html(d => Math.round(d.value));
        console.log(textNode.enter())
    }

    function sigmoidLine(d) { // topNode = parent, utop...
        const f = d.from;
        const t = d.to;
        //TODO always start the path with the parent --> child
        return "M" + f.x + "," + f.y
            + "C" + (f.x + t.x) / 2 + "," + f.y
            + " " + (f.x + t.x) / 2 + "," + t.y
            + " " + t.x + "," + t.y;
    };


    update();

    function updateNodeFromSlider(node) { //only update the
        d3.selectAll(`#circle_${node.id}`)
            .style("fill-opacity", `${node.value / 20}`)
        console.log(outputG)
        d3.select('#output')
            .attr('width', d => d.value)
            .attr('height', d => d.value)
        update();
    }


</script>
</html>