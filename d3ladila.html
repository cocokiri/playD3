<!doctype html>
<html>
<head>
    <style>
        svg {
            width: 500px;
            height: 500px
        }

        button {
            float: left
        }

        .line {
            stroke: red;
            stroke-width: 3;
        }

        text {
            font-size: 40px;
            font-family: Helvetica;
            fill: white;

            text-anchor: middle;
            text-align: center;
        }

        circle {
            fill: blue;
            stroke: orange;
            fill-opacity: 0.5;
        }

        .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .axis path {
            fill: none;
        }

        .axis text {
            font-size: 0.7em;
            fill: #555;
            font-family: sans-serif
        }
    </style>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="./gradientSchabernak.js"></script>
</head>
<body>
<script>




    const Node = class { //saves in object to have memory off variables (assignment by reference)...
        constructor({id, value = 20, gradient = 0, x = 200, y = 200}) {
            this.id = id;
            this.value = value;
            this.gradient = gradient;
            this.x = x;
            this.y = y
        }
    }

    const Gate_add = class { //or call Neuron
        constructor() {
        }

        forward(nodeA, nodeB) {
            this.nodeA = nodeA;
            this.nodeB = nodeB;

            this.x = nodeA.x + 200;
            this.y = this.nodeA.y/2 + this.nodeB.y/2;
            this.value = this.nodeA.value + this.nodeB.value

            this.outputNode = new Node({ //only value transfer at this stage, no reference
                value: this.value,

                id: `sum_${this.nodeA.id}${this.nodeB.id}`,
                x: this.nodeA.x + 420,
                y: this.nodeA.y/2 + this.nodeB.y/2 //between the two
            }, 0)
            return this.outputNode;
        }

        backward() {//derivative of xy ref x = x; that's why x ==> y
            // take the gradient in output unit and chain it with the
            // local gradients, which we derived for multiply gate before
            // then write those gradients to those Units.
            this.nodeA.gradient += 1 * this.outputNode.gradient; //f(x) = x + y; f`(x/dx) = 1
            this.nodeB.gradient += 1 * this.outputNode.gradient;
        }
    }

    const a = new Node({id:'a'})
    const b = new Node({id:'b', y:400})

    const addGate = new Gate_add();

    const outputAB = addGate.forward(a,b)

    console.log(a,b,addGate, outputAB)

    const lineFn = d3.line()
        .x(function (d) {
            return d.x + d.value/2;
        })
        .y(function (d) {
            return d.y + d.value/2;
        })
        .curve(d3.curveLinear);


    //TODO classes that go in arrays...with


    //GateMaker factory
    //Node maker


    //1)create Slides
    //2) attach to dom
    //3) add eventlisteners

    const inputNodes = [a,b]

    const l = inputNodes //TODO replace with simple node drag to change value
        .map(createSlider)
        .map(e => document.body.appendChild(e))

    function createSlider(node) { //TODO replace with action done UNTO element itself
        const sl = document.createElement('input')
        sl.setAttribute('type', 'range')
        sl.setAttribute('class', 'slider')
        sl.style.position = 'absolute'
        sl.style.left = node.x + 'px'
        sl.style.top = node.y + 'px'
        sl.setAttribute('id', node.id)
        sl.addEventListener('input', function () {
            node.value = +sl.value / 5
            console.log(node.value)
            updateNodeFromSlider(node, sl)
        })
        console.log(sl)
        return sl
    }

    var svg = d3.select('body')
        .append('svg');

    const areaGradient = svg.append("defs")
        .append("linearGradient")
        .attr("id","areaGradient")
        .attr("x1", "0%").attr("y1", "0%")
        .attr("x2", "0%").attr("y2", "100%");

    areaGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "orange")
        .attr("stop-opacity", 0.8);
    areaGradient.append("stop")
        .attr("offset", "120%")
        .attr("stop-color", "yellow")
        .attr("stop-opacity", 0.2);



    svg.style('width', window.innerWidth * 0.9).style('height', window.innerHeight * 0.9); //style instead of attr

    const dragState = {
        dragging: false,
        end: false,
        deltaY: 0,
        startY: 0
    }

    window.onmouseup = function(ev){ //can't be inside svg because ...whe
        ev.preventDefault();
        dragState.dragging = false;
        dragState.deltaY = 0;
    }

    let nodesG = svg.selectAll('gr')
        .data(inputNodes)
        .enter().append('g')
        .attr('transform', d => `translate(${d.x}, ${d.y})`)
        .on('mousedown', function(){
            event.preventDefault();
            dragState.dragging = true;
            dragState.startY = event.clientY;
            console.log(d3.event)
        })
        .on('mouseup', function(){
            event.preventDefault();
            dragState.dragging = false;
            dragState.deltaY = 0;
        })
        .on('mousemove', function(d) {
            if (!dragState.dragging) {return}
            event.preventDefault()
            if (dragState.dragging) {
                dragState.deltaY = dragState.startY - event.clientY
                console.log(dragState.deltaY)
            }

            d.value += dragState.deltaY/20;
            if (d.value < 0) {
                d.value = 0
            }
            dragState.deltaY = 0;
            updateNodeFromSlider(d)
        })

    const nodes = nodesG.append('rect')
        .attr('width', d => 60)
        .attr('height', d => 60)
        .attr('id', d => 'node_' + d.id)
        .attr('fill', "url(#areaGradient)")
        .attr('stroke', 'grey')
        .attr('stroke-opacity', '0.7')


    let textNode = nodesG.append('text')
        .attr("dx", d => +nodes.node().getAttribute('width')/2)
        .attr("dy", d => +nodes.node().getAttribute('height')/2)
        .classed('text', true)
        .html(d => d.value || "A")

    const gates = svg.selectAll('.gates').data( [addGate] )
        .enter().append('g')
        .attr('transform', d => `translate(${d.x}, ${d.y})`)
        .on('dragstart', d => console.log('hallo'))

    const rect = gates.append('rect')
        .attr('width', d => 60)
        .attr('height', d => 60)


    const text = gates.append("text") //TODO text always latest to be over other elems
        .attr("dx", d => rect.attr('width') /2)
        .attr("dy", d => rect.attr('height') / 1.5)
        .classed('text', true)
        .text("+")

    console.log(text)
    console.log(gates)

    const outputG = svg.selectAll('.output').data( [outputAB] )
        .enter().append('g')
        .attr('transform', (d, i) => `translate(${d.x}, ${d.y})`) //-- g doesn't do x, y coords...translate needed
    //NOW ALL CHILDREN ARE POSITIONED RELATIVE --- NO NEED TO SET ABSOLUTE VALUES

    outputG.append('rect')
        .attr('width', d => d.value)
        .attr('height', d => d.value)

    outputG.append('text')
        .attr("dy", ".35em")
        .text(d=> d.value)


    function update() {
        outputG.select('rect').attr('height', d => d.value)
        textNode.html(d => Math.round(d.value));
        console.log(textNode.enter())
    }

    const path1 = svg.selectAll('.line').data(inputNodes).enter()
        .append('path')
        .attr("d", d => lineFn([d, addGate]))
        .classed('line', true)

    const path2 = svg.selectAll('.line2').data( [addGate] ).enter()
        .append('path')
        .attr('d', d => lineFn([d, outputAB]))
        .classed('line', true)

    update();


    function sigmoidPath2(d) { // topNode = parent, utop...

        //TODO always start the path with the parent --> child
        return "M" + d.x + "," + d.y
            + "C" + (d.x + d.parent.x) / 2 + "," + d.y
            + " " + (d.x + d.parent.x) / 2 + "," + d.parent.y
            + " " + d.parent.x + "," + d.parent.y;
    };


    const testo = {
        x: 500,
        y: 200,
        parent: { //TODO this should be child
            x: 800,
            y: 500
        }
    }

    const testpath = sigmoidPath2(testo)



    var color = d3.interpolateLab("pink", "purple")//d3.interpolateRgb;

    const thenode = d3.select('svg').append('path').attr('d',testpath).remove()

    const splicedup = quads(samples(thenode.node(),8))

    const nodepath = d3.select('svg').selectAll('jew').data(splicedup).enter().append("path")

    nodepath
        .style("fill", function(d) { return color(d.t); })
        .style("stroke", function(d) { return color(d.t); })
        .attr("stroke-width", d => 10 - 10 * d.t )
        .attr("stroke-opacity", 0.3)
        .attr("d", function(d) { return lineJoin(d[0], d[1], d[2], d[3], 16 - 15 * d.t); });



    function draggingInput(d) {
        var x = d3.event.x;
        var y = d3.event.y;
        d3.select(this).attr("transform", "translate(" + x + "," + y + ")");
    }

    function updateNodeFromSlider(node) { //only update the
        d3.selectAll(`#circle_${node.id}`)
            .style("fill-opacity", `${node.value/20}`)

        outputG
            .attr('width', d => d.value)
            .attr('height', d => d.value)


        update();

    }


</script>
</html>