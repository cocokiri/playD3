<!doctype html>
<html>
<head>
    <style>
        svg {
            width: 500px;
            height: 500px
        }

        button {
            float: left
        }

        .line {
            stroke: red;
            stroke-width: 3;
        }

        text {
            font-size: 20px;
            font-family: Helvetica;
            fill: red;
            text-anchor: middle;
            text-align: center;
        }

        circle {
            fill: blue;
            stroke: orange;
            fill-opacity: 0.5;
        }

        .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .axis path {
            fill: none;
        }

        .axis text {
            font-size: 0.7em;
            fill: #555;
            font-family: sans-serif
        }
    </style>
    <script src="https://d3js.org/d3.v4.js"></script>
</head>
<body>
<script>

    console.log(d3)
    const firstlayerNodes = [3, 5, 9]

    //  debugger;


    //inputRange factory... give id from Node...
    //eventListener updates node
    //update() function that looks up id of SVG (from node) and changes value


    const Node = class {
        constructor(val, grad) {
            this.value = val;
            this.gradient = grad;
        }
    }

    const unitsData = [{
            id: 'a',
            x: 200,
            y: 200,
            size: 20
        },
        {
            id: 'b',
            x: 200,
            y: 400,
            size: 20
        }
    ]

    const gateData =[{
        id: "mult1",
        x: 400,
        y: 300,
        size: 40
    }]


    const lineFn = d3.line()
        .x(function (d) {
            return d.x;
        })
        .y(function (d) {
            return d.y;
        })
        .curve(d3.curveLinear);

    //GateMaker factory
    //Node maker
    const Gate_multiply = class { //or call Neuron
        constructor() {
        }
        forward(nodeA, nodeB) {
            this.nodeA = nodeA;
            this.nodeB = nodeB;
            this.nodeTop = new Node(nodeA.value * nodeB.value, 0)
        }
        backward(){//derivative of xy ref x = x; that's why x ==> y
            // take the gradient in output unit and chain it with the
            // local gradients, which we derived for multiply gate before
            // then write those gradients to those Units.
            this.nodeA.gradient += this.nodeB.value * this.nodeTop.gradient;
            this.nodeB.gradient += this.nodeA.value * this.nodeTop.gradient;
        }
    }


    const slider = d3.select('.slider');
//    slider.on('input', updateCirc)
    console.log(slider, "val slide")



    //create Slides
    //2) attach to dom
    //3) add eventlisteners
    function createSlider(node){
        const sl = document.createElement('input')
        sl.setAttribute('type', 'range')
        sl.setAttribute('class', 'slider')
        sl.style.position = 'absolute'
        sl.style.left = node.x + 'px'
        sl.style.top = node.y + 'px'
        sl.setAttribute('id', node.id)
        sl.addEventListener('input', function() {
            node.size = +sl.value/5
            console.log(node.size)
            updateNodeFromSlider(node, sl)
        })
        console.log(sl)
        return sl
    }

    document.body.appendChild(createSlider(unitsData[0]))


    var svg = d3.select('body')
        .append('svg');

    svg.style('width', window.innerWidth).style('height', window.innerHeight); //style instead of attr


    let nodes = svg.selectAll('gr')
            .data(unitsData)
            .enter().append('g')
            .attr('x', d=> d.x)
        .attr('y', d => d.y)




    const c = nodes.append('circle');

    c.enter().merge(c).attr('cx', d => +d.x)
        .attr('cy', d => +d.y)
        .attr('r', d => +d.size)
        .attr('id', d=> 'circle_' + d.id)

    c.each(function(node) {

        console.log(node, this);

    })

    const textNode = nodes.append('text')
        .attr('x', d=> d.x)
        .attr('y', d => d.y)
        .attr("dy", ".35em")
        .classed('text', true)
        .text("TTT")

    const gates = svg.selectAll('rects').data(gateData).enter().append('g')
        .attr('x', d => d.x)
        .attr('y', d => d.y)

    const rect = gates.append('rect')
        .attr('x', d => d.x)
        .attr('y', d => d.y)
        .attr('width', d => d.size)
        .attr('height', d => d.size)

    const text = gates.append("text")
        .attr('x', d=> d.x)
        .attr('y', d => d.y)
        .attr("dy", ".35em")
        .classed('text', true)
        .text("YOLO")

    const path1 = svg.selectAll('.line').data([0]).enter()
        .append('path')
        .attr("d", lineFn([unitsData[0], gateData[0]]))
        .classed('line',true)

    const circles = svg.selectAll('circle')
        .data(firstlayerNodes)
        .enter()
        .append('circle')


    updateCirc()

    function forEignObjBS(){
        var svg = d3.select("svg").append("svg")
            .attr("width", 100)
            .attr("height", 100);

        svg.append("foreignObject")
            .attr("width", 100)
            .attr("height", 100)
            .html("<input type=checkbox id=check />")
            .on("click", function(d, i){
                console.log(svg.select("#check").node().checked);
            });

    }

    function updateNodeFromSlider(node,sli){ //only update the
//        if (sli.id === node.id){
            d3.selectAll(`#circle_${node.id}`)
                .attr("r", node.size)
//        }
    }

    function updateCirc() {
        circles.attr('cx', 50).attr('cy', (d, i) => i * 100).attr('r', d => +slider.property('value') / 10 * d)
    }


</script>
</html>